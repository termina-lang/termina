#[packed]
struct UARTRegs {
    data : u32;
    status : u32;
    control :  u32;
    scaler : u32;
};

struct TMDescriptorT {

    tm_bytes : [u8 ; 256];
    tm_num_bytes : u16;

};


resource class UARTDriver{

    uart_regs: loc UARTRegs;

    procedure riscv_uart_tf_is_empty(&priv self, res : &mut bool) {
        let riscv_uart_te : u32 = 0x00000004 : u32;
        *res = ((self->uart_regs.status & riscv_uart_te) != 0 : u32);
        return;
    }
};


resource class TMChannel{

   uart : port UARTDriver;
   // pool : port Pool<TMDescriptorT;20>;


    procedure send_tm(&priv self, tm_descriptor: dyn TMDescriptorT,result : &mut Result){


        let timeout : u32 = 0xAAAAA : u32;
        var write_timeout : u32 = 0 : u32;
        var check : bool = false;


        self->uart.riscv_uart_tf_is_empty(&mut check);

        for k : u32 in 0 : u32 .. timeout while check == false {

            self->uart.riscv_uart_tf_is_empty(&mut check);
            write_timeout = write_timeout + 1 : u32;

        }

        if (write_timeout < timeout){

            *result = Result::Ok;

        }
        else{

            *result = Result::Error;
        }

        free(tm_descriptor);


        return;

    }

   };
