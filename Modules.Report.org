#+title: Modules Report

* DONE Termina programs are imports + declarations

#+begin_src termina
imports { ... }
[declarations]
#+end_src

Parser + ParserAST
* DONE Analyze order.
** DONE First POC. Á la C
There is a main (root) file and we load files in demand.
** DONE Implement TopSort
General enough to use it somewhere else.
** DONE Tree-like modules + siblings visibility
*** DONE Dir imports.
#+begin_src termina
import { D1.D2.Mod }
...
#+end_src
If ~./D1/D2/Mod~ is a directory, read file ~./D1/D2/Mod/src.fin~
*** DONE File import
#+begin_src termina
import { D1.D2.Mod }
...
#+end_src
If ~./D1/D2/Mod.fin~ exists, read file ~./D1/D2/Mod.fin~

* DONE Semantic Analyze each module
** DONE Homogeneous inclusion
I am inventing the name. Everything seems to be as if the whole project were in
a single file.
** DONE Add meta-data to improve errors
Global have annotation from the original source code.
** DONE Print an error as example.

* DONE PPrint each module mimicking Project structure.

* TODO Project File. Á la all-modern-compilers.
There is a project file YAML,JSon or whatever, where there is a file noted as
main and then we do something similar to the previous approach.

* IDEA Lazy Read files first.
Optimization (I know, it smells like poop already). Open each file as lazy
streams and before anything sort them, and after that, continue processing each
file.
So, we first set and order, and only then, read files, parse and type them.
By doing so, we do not need to load the whole project on memory.
