{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase       #-}
{-# LANGUAGE TupleSections    #-}

-- | Semantic Analysis Module i.e. Type checking
-- In particular this module, describes a mapping from |AST Parser.Annotation| to |AST SemanticAnnotations|

module Semantic.TypeChecking where

-- Termina Stuff
import           AST

-- Just annotations from Parser
import qualified Parsing as Parser (Annotation(..))

-- Interpretation of types
import Semantic.Types
-- Error module
import Semantic.Errors
-- Semantic Monad
import Semantic.Monad

----------------------------------------
-- Libaries and stuff

import           Data.List                  (foldl', sort, sortOn)

-- import Control.Monad.State as ST
import           Data.Map                   as M

import           Control.Arrow


-------------
-- More helers, incomplete errors
-- Function to type check types of binary operations.
-- It returns resulting type of using an operation.
typeOfOps :: Locations -> Op -> Type -> Type -> SemanticMonad Type
typeOfOps locs op lty = maybe (return lty) (throwError . annotateError locs . uncurry EMismatch) . typeOfOps' op lty
where
  typeOfOps' :: Op -> Type -> Type -> Maybe (Type,Type)
  -- Alg ops Same numeric type
  typeOfOps' Multiplication tyl tyr = cmpNumTy tyl tyr
  typeOfOps' Division tyl tyr = cmpNumTy tyl tyr
  typeOfOps' Addition tyl tyr = cmpNumTy tyl tyr
  typeOfOps' Substraction tyl tyr = cmpNumTy tyl tyr
  -- shifts both numeric but may not be the same
  -- Q2
  typeOfOps' BitwiseLeftShift tyl tyr = justNumTy tyl tyr
  typeOfOps' BitwiseRightShift tyl tyr = justNumTy tyl tyr
  -- >, =>, <, <= : some numeric type.
  typeOfOps' RelationalLT tyl tyr = cmpNumTy tyl tyr
  typeOfOps' RelationalLTE tyl tyr =cmpNumTy tyl tyr
  typeOfOps' RelationalGT tyl tyr =cmpNumTy tyl tyr
  typeOfOps' RelationalGTE tyl tyr =cmpNumTy tyl tyr
  -- Equiality: TODO I think we said structural equality, but not sure.
  typeOfOps' RelationalEqual tyl tyr = sameTyOne tyl tyr
  typeOfOps' RelationalNotEqual tyl tyr = sameTyOne tyl tyr
  -- Bitwise. I guess this is like C so nums?
  typeOfOps' BitwiseAnd tyl tyr = cmpNumTy tyl tyr
  typeOfOps' BitwiseOr tyl tyr =cmpNumTy tyl tyr
  typeOfOps' BitwiseXor tyl tyr =cmpNumTy tyl tyr
  -- Logical And/Or bool
  typeOfOps' LogicalAnd tyl tyr = justBoolTy tyl tyr
  typeOfOps' LogicalOr tyl tyr  = justBoolTy tyl tyr
  sameTyOne t t' =
    if sameTy t t'
    then Nothing
    else Just (t,t')
  cmpNumTy t t' =
    if sameNumTy t t'
    then Nothing
    else Just (t,t')
  justNumTy t t' =
    if numTy t && numTy t'
    then Nothing
    else Just (t,t')
  justBoolTy t t' =
    if boolTy t && boolTy t'
    then Nothing
    else Just (t,t')

-- Checks param types.
-- checkParamTy :: SemMonad m => Type -> Expression Parser.Annotations -> SemanticMonad (Expression SemanticAnns )
-- checkParamTy pTy aTy =
--   expressionType aTy >>= \texp ->
--     withError (const (EParam pTy texp)) (void (pTy =?= texp))

paramTy :: [Parameter] -> [Expression Parser.Annotations] -> SemanticMonad ([Expression SemanticAnns])
paramTy [] [] = return ()
paramTy (p : ps) (a : as) = checkParamTy (paramTypeSpecifier p) a >> paramTy ps as
paramTy _ _ = throwError EFunParams
  where checkParaTy pTy exp =
          expressionType exp >>=

--
casteableTys :: Type -> TypeSpecifier SemAnn -> Bool
casteableTys UInt8 UInt16  = True
casteableTys UInt16 UInt32 = True
casteableTys UInt32 UInt64 = True
casteableTys Int8 Int16    = True
casteableTys Int16 Int32   = True
casteableTys Int32 Int64   = True
-- Last option being the same.
-- This is a trivial casting :muscle:
casteableTys a b           = sameTy a b

expressionType :: SemMonad m => Expression SemAnn -> m Type
expressionType (Variable a) =
  -- | Check if it is a local variable. And its typing rule
  {-
\[
\begin{array}{c}
\inferce[evarG]
{ (x, \tau) \in G}
% ----------------------------------------
{G, L, RO \vdash x : \tau}\\
\inferce[evarL]
{ (x, \tau) \in L}
% ----------------------------------------
{G, L, RO \vdash x : \tau}\\
\inferce[evarRO]
{ (x, \tau) \in RO}
% ----------------------------------------
{G, L, RO \vdash x : \tau}
\end{array}
\]
-}
  gets local >>= \locals ->
  case M.lookup a locals of
    Just t -> return t
    Nothing -> gets global >>= \glbs ->
      case M.lookup a glbs of
        Just (GGlob gvars) -> return (getTySemGlobal gvars)
        _                  -> throwError ENotVar
expressionType (Constant c) =
  -- | Constants
  {-
\[
\begin{array}{c}
\inference[econstTrue]
% ----------------------------------------
{ \_ \vdash true : \mathsf{Bool}}\\
\inference[econstFalse]
% ----------------------------------------
{ \_ \vdash false : \mathsf{Bool}}\\
\inference[econstIntX]
{n \in \mathsf{IntX}}
% ----------------------------------------
{\_ \vdash n : \mathsf{IntX}}\\
\inference[econstC]
% ----------------------------------------
{ \_ \vdash c : \mathsf{Char}}
\end{array}
\]
-}
  case c of
    B b -> return Bool
    I tyI i ->
      -- DONE Q8
      if numTy tyI then return tyI else throwError (ENumTs [tyI])
    C c -> return Char

expressionType (Casting e nty) =
  -- | Casting Expressions.
  {-
\[
\inference[eCast]
{E \vdash e : \tau \\ \tau \subseteq \theta}
% ----------------------------------------
{ E \vdash e as \theta : \theta}
\]
-}
  expressionType e >>= \ety ->
  if casteableTys ety nty -- ety \subseteq nty
  then return nty else throwError (ECasteable ety nty)
expressionType (BinOp op le re) = do
  -- | Binary operation typings
  {-
\[
\inference[eBOps]{
  E \vdash e_1 : \theta_1 \\
  E \vdash e_2 : \theta_2 \\
  Type(\oplus)(\theta_1,\theta_2) = \tau \\
}
% ----------------------------------------
{ E \vdash e_1 \oplus e_2 : \tau}
\]
-}
  tyle <- expressionType le
  tyre <- expressionType re
  typeOfOps op tyle tyre
expressionType (ReferenceExpression e) =
  -- | Reference Expression
  -- TODO [Q15]
  Reference <$> expressionType e
-- Function call?
expressionType (FunctionExpression fun_name args) =
  -- | Function Expression.  A tradicional function call
  {-
\[
\inference[eFuncCall]{
  (f, \texttt{Func}(\mathsf{Args}, \tau)) \in G \\
  (a_1, \tau_1) \in G \cup L \cup RO \\
  \ldots \\
  (a_n, \tau_n) \in G \cup L \cup RO \\
  (\tau_1, \ldots, \tau_n) \in Args \\
}
% ----------------------------------------
{ G,L,RO \vdash f(a_1, \ldots, a_n) : \tau}
\]
-}
   gets global >>= \glbs ->
    case M.lookup fun_name glbs of
      Just (GFun (SFunction pTy retTy _anns)) ->
        paramTy pTy args >> return retTy
      Just ge -> throwError (ENotFoundFun fun_name ge)
      Nothing ->  throwError (ENotAFun fun_name)
expressionType (FieldValuesAssignmentsExpression id_ty fs) =
  -- | Field Type
  {-
\[
\begin{array}{c}
\inference[eStruct]
{
  (\mathsf{RcTy}, \texttt{Struct}(\mathsf{Fields})) \in G \\
  (r_i, \tau_i) \in \mathsf{Fields}, i \in [1, \ldots, n] \\
  \mathsf{Fields} \setminus \{r_1, \ldots, r_n \} = \emptyset \\
  G , L , RO \vdash e_i : \tau_i,  i \in [1, \ldots, n]
}
% ----------------------------------------
{ G, L , RO \vdash  \mathsf{RcTy} \{ r_1 = e_1 , \ldots , r_n = e_n \} : \mathsf{RcTy}}\\
\inference[eUnion]
{
  (\mathsf{UnionTy}, \texttt{Union}(\mathsf{Fields})) \in G \\
  (r_i, \tau_i) \in \mathsf{Fields}, i \in [1, \ldots, n] \\
  \mathsf{Fields} \setminus \{r_1, \ldots, r_n \} = \emptyset \\
  G , L , RO \vdash e_i : \tau_i,  i \in [1, \ldots, n]
}
% ----------------------------------------
{ G, L , RO \vdash  \mathsf{UnionTy} \{ r_1 = e_1 , \ldots , r_n = e_n \} : \mathsf{UnionTy}}\\
\end{array}
\]
-}
  getNameTy id_ty >>= \case {
   Struct _ ty_fs _mods _ann ->
       checkFieldValues ty_fs fs >> return (DefinedType id_ty) ;
   Union _ ty_fs _mods _ann ->
       checkFieldValues ty_fs fs >> return (DefinedType id_ty) ;
   _ -> throwError (ETyNotStruct id_ty);
  }
expressionType (VectorIndexExpression vec_exp index_exp) =
  -- | VectorIndex.
  {-
\[
\inference[eVectorIndex]
{ G, L, RO \vdash v : \mathsf{Vector}(\tau) \\
  G, L, RO \vdash e : \theta \\
  \mathsf{Index}(\theta)
}
% ----------------------------------------
{ G, L, RO \vdash v[e] : \tau}
\]
-}
  expressionType vec_exp >>= \case {
    Vector ty_elems _vexp ->
        expressionType index_exp >>= \ity ->
        if numTy ity then return ty_elems
        else throwError (ENumTs [ity])
    ;
    ty -> throwError (EVector ty);
                                   }
-- IDEA Q4
expressionType (VectorInitExpression iexp lexp@(Constant c)) = do
-- | Vector Initialization
{-
\inference[eVecInit]
{
G, L, RO \vdash e : \tau \\
c \in Ty \\ TODO Q16
}
% ----------------------------------------
{G , L , RO \vdash [ e ; c : Ty ] : \mathsf{Vector}(\tau, c)}
-}
  init_ty <- expressionType iexp
  len_ty <- expressionType lexp
  if numTy len_ty
  then Vector init_ty . K <$> getIntConst c
  else throwError (ENumTs [len_ty])
expressionType (VectorInitExpression _ lexp) = throwError (EVectorConst lexp)
-- DONE [Q5]
-- TODO [Q17]
expressionType (MatchExpression e cs) =
  -- | Pattern Matching.
  {-
\[
\begin{array}{c}
\inference[OptionMatch]
{ G, L, RO |- e : Option(\theta) \\
  G, L, RO |- e_2 : \tau \\
  G, L \cup \{(x, \theta)\}, RO |- e_1 : \tau \\
}
% ----------------------------------------
{ G,L,RO |- match(e){case Some(x) => e_1; case None => e_2 } : \tau}\\
\inference[GenMatch]
{ G,L,RO |- e : \mathsf{Enum}(\overline{cs}) \\
  G,L \cup \{(\overline{c_i} \cdot \overline{\tau_i})\},RO |- e_i : \tau (C_i, \overline{\tau_i}) \in \overline{cs}\\
  \overline{cs} \setminus \{ C_1, \ldots, C_n \} = \emptyset
}
{ G,L,RO |- match(e){case C_1(\overline{c_1}) => e_1; ... ; case C_n(\overline{c_n}) => e_n } : \tau}
\end{array}
\]
-}
  expressionType e >>= \case {
  -- Base Types PM
   Option pty     -> pmOption pty cs;
   ;
  -- User defined PM only Enums
   DefinedType id -> getEnumTy id >>= pmEnums cs
   }

-- Zipping list of same length
zipSameLength ::  ([b] -> e) -> ([a] -> e) -> (a -> b -> c) -> [a] -> [b] -> Either e [c]
zipSameLength ea eb f as bs = zipSameLength' ea eb f as bs []
  where
    -- Tail recursive version
    zipSameLength' :: ([b] -> e) -> ([a] -> e) -> (a -> b -> c) -> [a] -> [b] -> [c] -> Either e [c]
    zipSameLength' _ _ _ [] [] acc = Right acc
    zipSameLength' ea eb f (a : as) (b : bs) acc = zipSameLength' ea eb f as bs (f a b : acc)
    zipSameLength' ea _ _ [] bs _ = Left (ea bs)
    zipSameLength' _ eb _ as [] _ = Left (eb as)
--

-- Not assuming anything. Ordering matchs just in case.
pmEnums :: SemMonad m => [MatchCase SemAnn] -> [EnumVariant SemAnn] -> m Type
pmEnums mc evs = join $ checkSame <$> (zipWithM pmEnumsS sorted_mc sorted_evs)
  where
    checkSame :: SemMonad m => [Type] -> m Type
    checkSame []     = throwError EMCEmpty
    checkSame (t:ts) = foldM (=?=) t ts
    sorted_mc :: [MatchCase SemAnn]
    sorted_mc = sortOn matchIdentifier mc
    sorted_evs :: [EnumVariant SemAnn]
    sorted_evs = sortOn variantIdentifier evs
    pmEnumsS :: SemMonad m => MatchCase SemAnn -> EnumVariant SemAnn -> m Type
    pmEnumsS mc ev =
      if matchIdentifier mc == variantIdentifier ev
      then
        either throwError
        (\scope -> addTempVars
          scope
          (retblockType (matchBody mc)))
        (zipSameLength EMCMissingArgs EMCMoreArgs (,) (matchBVars mc) (assocData ev))
      else throwError (EMCMissingEnum (variantIdentifier ev))


pmOption :: SemMonad m => Type -> [MatchCase SemAnn] -> m Type
pmOption ty [cs1, cs2] =
  if matchIdentifier cs1 == "None" then pmOption' ty cs1 cs2
  else pmOption' ty cs2 cs1
  where
    noneConditions cs = matchIdentifier cs == "None" && Prelude.null(matchBVars cs)
    someConditions cs = matchIdentifier cs == "Some" && length(matchBVars cs) == 1
    -- I am sure this could be improved
    pmOption' :: SemMonad m => Type -> MatchCase SemAnn -> MatchCase SemAnn -> m Type
    pmOption' ty csnone cssome =
     if noneConditions csnone
     then if someConditions cssome
          then do
            tyNone <- retblockType (matchBody csnone)
            tySome <- case matchBVars cssome of
              [v] -> addTempVars [(v,ty)] (retblockType (matchBody cssome))
              _   -> throwError EPMMoreOptionsVariables
            tyNone =?= tySome
          else throwError EPMMissingOption1
     else throwError EPMMissingOption0
pmOption _ []        = throwError EPMMissingOption0
pmOption _ [_]       = throwError EPMMissingOption1
pmOption _ _ = throwError EPMMoreOptions

checkFieldValue :: SemMonad m => FieldDefinition SemAnn -> FieldValueAssignment SemAnn  -> m ()
checkFieldValue (FieldDefinition fid fty) (FieldValueAssignment faid faexp) =
  if fid == faid
  then expressionType faexp >>= void . (fty =?=)
  else throwError (EFieldMissing [fid])

checkFieldValues :: SemMonad m => [FieldDefinition SemAnn] -> [FieldValueAssignment SemAnn] -> m ()
checkFieldValues fds fas = checkSortedFields sorted_fds sorted_fas
  where
    sorted_fds = sortOn fieldIdentifier fds
    sorted_fas = sortOn fieldAssigIdentifier fas
    checkSortedFields [] [] = return ()
    checkSortedFields [] es = throwError (EFieldExtra (fmap fieldAssigIdentifier es))
    checkSortedFields ms [] = throwError (EFieldMissing (fmap fieldIdentifier ms))
    checkSortedFields (d:ds) (a:as) =
      checkFieldValue d a >> checkSortedFields ds as

retblockType :: SemMonad m => BlockRet SemAnn -> m Type
retblockType (BlockRet bbody (ReturnStmt mret _mods _anns)) =
  -- Blocks should have their own scope.
  blockType bbody
  >> maybe (return Unit) expressionType mret

blockType :: SemMonad m => Block SemAnn -> m ()
blockType = mapM_ statementTySimple

-- | Type checking statements. We should do something about Break
-- Rules here are just environment control.
statementTySimple :: SemMonad m => Statement SemAnn -> m ()
-- Declaration semantic analysis
statementTySimple (Declaration lhs_id lhs_type Nothing _mods _anns) =
{-
\[
\inference[varDecDef]
{ x \notin G \cup L \cup RO % No shadow binding
  \mathsf{Default}(\tau) % \tau accepts default value? TODO Q18
}
% ----------------------------------------
{G, L, RO |- \texttt{var} x : \tau  \leadsto G,L \cup \{(x,\tau)\}, RO}
\]
-}
  addVars[(lhs_id, lhs_type)]
statementTySimple (Declaration lhs_id lhs_type (Just expr) _mods _anns) =
{-
\[
\inference[varDecVal]
{ x \notin G \cup L \cup RO % No shadow binding
  G, L, RO |- e : \tau \\
}
% ----------------------------------------
{ (G, L, RO) \{ \texttt{var} x : \tau = e \}(G,L \cup \{(x,\tau)\}, RO)}
\]
-}
  ((lhs_type =?=) =<<) (expressionType expr) >>
  addVars [(lhs_id,lhs_type)]
statementTySimple (AssignmentStmt lhs_id rhs_expr _mods _anns) =
{- TODO Q19
\[
\inference[assign]
{ (x, \tau) \in L \\
  G, L, RO |- e : \tau
}
% ----------------------------------------
{(G, L, RO) \{x = e\} (G,L \cup \{(x,\tau)\}, RO)}
\]
-}
  void $ join $ (=?=) <$> getDefinedVarTy lhs_id <*> expressionType rhs_expr
statementTySimple (IfElseStmt cond_expr tt_branch elifs otherwise_branch _mods _anns) =
{-
\[
\inference[ifElse]
{  G, L, RO |- e : \mathsf{Bool} \\
  {G, L, RO} \{ b_{tt} \} {G, L, RO} \\
  {G, L, RO} \{ b_{ff} \} {G, L, RO} \\
}
% ----------------------------------------
{(G, L, RO) \{ \texttt{if} (e) \{ b_{tt} \} \texttt{else} \{ b_{ff}\}  \} (G,L,RO)}
\]
-}
  let (cs, bds) = unzip (Prelude.map (\c -> (elseIfCond c, elseIfBody c)) elifs) in
  mapM_ (join . ((Bool =?=) <$>) . expressionType) (cond_expr : cs) >>
  mapM_ (localScope . blockType) ([tt_branch] ++ bds ++ [otherwise_branch])
-- Here we could implement some abstract interpretation analysis
statementTySimple (ForLoopStmt it_id from_expr to_expr Nothing body_stmt _mods _ann) = do
{-
\[
\inference[forLoop]
{ G, L, RO |- e_{l} : \tau  \\
  G, L, RO |- e_{u} : \tau \\
  \mathsf{NumTy}(\tau) \\
  \llbraces e_{l} \rrbraces \leq \llbraces e_{u} \rrbraces \\
  {G, L, RO \cup \{(i, \tau)\}} \{ b_{body} \} {G, L, RO \cup \{(i, \tau)\}}
}
% ----------------------------------------
{(G, L, RO) \{ \texttt{for} i \texttt{in} e_{l} e_{u} { \mathsf{body} } \} (G,L,RO)}
\]
-}
  from_ty <- expressionType from_expr
  to_ty <- expressionType to_expr
  if sameNumTy from_ty to_ty
  then addTempVars [(it_id,from_ty)] (blockType body_stmt)
  else throwError EBadRange
statementTySimple (ForLoopStmt it_id from_expr to_expr (Just while) body_stmt _mods _ann) = do
{-
\[
\inference[forLoop]
{ G, L, RO |- e_{l} : \tau  \\
  G, L, RO |- e_{u} : \tau \\
  G, L, RO |- e_{w} : \mathsf{Bool} \\
  \mathsf{NumTy}(\tau) \\
  \llbraces e_{l} \rrbraces \leq \llbraces e_{u} \rrbraces \\
  {G, L, RO \cup \{(i, \tau)\}} \{ b_{body} \} {G, L, RO \cup \{(i, \tau)\}}
}
% ----------------------------------------
{(G, L, RO) \{ \texttt{for} i \texttt{in} e_{l} e_{u} \texttt{while} e_{w} { \mathsf{body} } \} (G,L,RO)}
\]
-}
  from_ty <- expressionType from_expr
  to_ty <- expressionType to_expr
  while_ty <- expressionType while
  if (sameTy Bool while_ty) then
    if sameNumTy from_ty to_ty
    then addTempVars [(it_id,from_ty)] (blockType body_stmt)
    else throwError EBadRange
  else throwError $ EForWhileTy while_ty

statementTySimple (SingleExpStmt expr _mods _anns) =
{-
\[
\inference[singleExp]
{ G, L, RO |- e : \tau  \\}
% ----------------------------------------
{(G, L, RO) \{ e \} (G,L,RO)}
\]
-} void $ expressionType expr

----------------------------------------
-- Programs Semantic Analyzer
-- For now all are kinda the same thing but eventually they should not :shrug:
----------------------------------------
-- TODO : Rewrite this last part.
-- We do not need a local environment here. Take it out.

-- Task Semantic Analyzer
taskSemAnalyzer :: SemMonad m
  => [Parameter SemAnn] -> TypeSpecifier SemAnn
  -> BlockRet SemAnn -> SemAnn -> m SemTask
taskSemAnalyzer taskPs taskRetType taskBody anns =
  -- | Add
  addTempVars
    -- | list of variables
    (fmap (\p -> (paramIdentifier p, paramTypeSpecifier p)) taskPs)
    -- | analyze the body and check the returining type
    ((taskRetType =?=) =<< (retblockType taskBody))
  >> return (STask taskPs taskRetType anns)

-- Function Semantic Analyzer
functionSemAnalyzer :: SemMonad m => [Parameter SemAnn]
  -> (Maybe (TypeSpecifier SemAnn)) -> (BlockRet SemAnn) -> SemAnn -> m SemFunction
functionSemAnalyzer funPS mbfunRetTy funBody anns =
  (-- | Add scoped variables Q17
  addTempVars
  (fmap (\ p -> (paramIdentifier p , paramTypeSpecifier p)) funPS)
  $ -- within the scope + parameters, check body type
  case mbfunRetTy of
    -- [Q12] Do we accept procedures?
    Nothing    -> return Unit
    Just retTy -> (retTy =?=) =<< (retblockType funBody)) >>= \ty -> return (SFunction funPS ty anns)

-- Handler Semantic Analyzer (Template)
handlerSemAnalyzer :: SemMonad m =>
  [Parameter SemAnn] -> (TypeSpecifier SemAnn) -> (BlockRet SemAnn) -> SemAnn -> m SemHandler
handlerSemAnalyzer hanPS hanType hanBody anns =
  (addTempVars (fmap (\p -> (paramIdentifier p, paramTypeSpecifier p)) hanPS)
              $ (hanType =?=) =<< (retblockType hanBody)) >>=
  \ty -> return (SemHandler hanPS ty anns)


-- Keeping only type information
globalCheck :: SemMonad m => Global SemAnn -> m (Identifier, SemGlobal)
globalCheck (Volatile ident ty addr _mods anns) = return (ident, SVolatile ty anns)
-- DONE [Q13]
globalCheck (Static ident ty (Just (Constant _Address)) _mods anns) = return $ (ident , SStatic ty anns)
globalCheck (Static _ _ _ _ _) = throwError EStaticK
--
globalCheck (Shared ident ty mexpr _mods anns) =
  case mexpr of
    -- If it has an initial value great
    Just expr -> do
      eTy  <- expressionType expr
      _ <- ty =?= eTy
      return (ident ,SShared ty anns)
    -- If it has not, we need to check for defaults.
    Nothing -> return (ident, SShared ty anns)
-- TODO [Q14]
globalCheck (Const ident ty expr _mods anns) = do
      eTy  <- expressionType expr
      _ <- ty =?= eTy
      return (ident , SConst ty anns)

-- Global Helpers
-- | Add global member if it doesn't exists
addGlobal :: SemMonad m => Identifier -> GEntry -> m ()
addGlobal ident gentry =
  -- | Lookup if |ident| is already in global map
  ((M.lookup ident) <$> (gets global)) >>=
  maybe
    -- | If it is not par of the global map
    (modify (\s -> s{global = M.insert ident gentry (global s)}))
    -- | If it is defined
    (const $ throwError $ EDefinedGEntry gentry)

-- Here we actually only need Global
programSeman :: SemMonad m => AnnASTElement SemAnn -> m ()
programSeman (Task ident ps ty bret _mods anns) =
  addGlobal ident . GTask =<< taskSemAnalyzer ps ty bret anns
programSeman (Function ident ps mty bret _mods anns) =
  addGlobal ident . GFun =<< functionSemAnalyzer ps mty bret anns
programSeman (Handler ident ps ty bret _mods anns) =
  addGlobal ident . GHand =<< handlerSemAnalyzer ps ty bret anns
programSeman (GlobalDeclaration gbl) =
  (uncurry addGlobal) =<< ((\(nn,gg) -> (nn, GGlob gg)) <$> globalCheck gbl)
programSeman (TypeDefinition tydef) = _TypeDefinition
programSeman (ModuleInclusion ident _mods anns) = _ModuleInclusion
