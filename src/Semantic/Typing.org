#+title: Typing Inference Rules

* Variables
#+begin_src latex
\[
\begin{array}{c}
\inferce[evarG]
{ (x, \tau) \in G}
% ----------------------------------------
{G, L, RO \vdash x : \tau}\\
\inferce[evarL]
{ (x, \tau) \in L}
% ----------------------------------------
{G, L, RO \vdash x : \tau}\\
\inferce[evarRO]
{ (x, \tau) \in RO}
% ----------------------------------------
{G, L, RO \vdash x : \tau}
\end{array}
\]
#+end_src

* Constants
#+begin_src latex
\[
\begin{array}{c}
\inference[econstTrue]
% ----------------------------------------
{ \_ \vdash true : \mathsf{Bool}}\\
\inference[econstFalse]
% ----------------------------------------
{ \_ \vdash false : \mathsf{Bool}}\\
\inference[econstIntX]
{n \in \mathsf{IntX}}
% ----------------------------------------
{\_ \vdash n : \mathsf{IntX}}\\
\inference[econstC]
% ----------------------------------------
{ \_ \vdash c : \mathsf{Char}}
\end{array}
\]

#+end_src

* Casting Expressions
#+begin_src latex
\[
\inference[eCast]
{E \vdash e : \tau \\ \tau \subseteq \theta \equiv casteableTys(\tau,\theta)}
% ----------------------------------------
{ E \vdash e as \theta : \theta}
\]

#+end_src
* Binary Ops
#+begin_src latex
\[
\inference[eBOps]{
  E \vdash e_1 : \theta_1 \\
  E \vdash e_2 : \theta_2 \\
  Type(\oplus)(\theta_1,\theta_2) = \tau \\
}
% ----------------------------------------
{ E \vdash e_1 \oplus e_2 : \tau}
\]
#+end_src

* Function Expression
#+begin_src latex
\[
\inference[eFuncCall]{
  (f, \texttt{Func}(\mathsf{Args}, \tau)) \in G \\
  (a_1, \tau_1) \in G \cup L \cup RO \\
  \ldots \\
  (a_n, \tau_n) \in G \cup L \cup RO \\
  (\tau_1, \ldots, \tau_n) \in Args \\
}
% ----------------------------------------
{ G,L,RO \vdash f(a_1, \ldots, a_n) : \tau}
\]
#+end_src

* FieldValues Assignment
#+begin_src latex
\[
\begin{array}{c}
\inference[eStruct]
{
  (\mathsf{RcTy}, \texttt{Struct}(\mathsf{Fields})) \in G \\
  (r_i, \tau_i) \in \mathsf{Fields}, i \in [1, \ldots, n] \\
  \mathsf{Fields} \setminus \{r_1, \ldots, r_n \} = \emptyset \\
  G , L , RO \vdash e_i : \tau_i,  i \in [1, \ldots, n]
}
% ----------------------------------------
{ G, L , RO \vdash  \mathsf{RcTy} \{ r_1 = e_1 , \ldots , r_n = e_n \} : \mathsf{RcTy}}\\
\inference[eUnion]
{
  (\mathsf{UnionTy}, \texttt{Union}(\mathsf{Fields})) \in G \\
  (r_i, \tau_i) \in \mathsf{Fields}, i \in [1, \ldots, n] \\
  \mathsf{Fields} \setminus \{r_1, \ldots, r_n \} = \emptyset \\
  G , L , RO \vdash e_i : \tau_i,  i \in [1, \ldots, n]
}
% ----------------------------------------
{ G, L , RO \vdash  \mathsf{UnionTy} \{ r_1 = e_1 , \ldots , r_n = e_n \} : \mathsf{UnionTy}}\\
\end{array}
\]
#+end_src

* ArrayIndex Expression
#+begin_src latex
\[
\inference[eArrayIndex]
{ G, L, RO \vdash v : \mathsf{Array}(\tau) \\
  G, L, RO \vdash e : \theta \\
  \mathsf{Index}(\theta)
}
% ----------------------------------------
{ G, L, RO \vdash v[e] : \tau}
\]

#+end_src

* Array InitExpresssion
#+begin_src latex
\inference[eVecInit]
{
G, L, RO \vdash e : \tau \\
c \in Ty \\ TODO Q16
}
% ----------------------------------------
{G , L , RO \vdash [ e ; c : Ty ] : \mathsf{Array}(\tau, c)}
#+end_src
* MatchExpression
This is not an Expression anymore.
#+begin_src haskell
expressionType (MatchExpression e cs) =
  -- | Pattern Matching.
  {-
\[
\begin{array}{c}
\inference[OptionMatch]
{ G, L, RO |- e : Option(\theta) \\
  G, L, RO |- e_2 : \tau \\
  G, L \cup \{(x, \theta)\}, RO |- e_1 : \tau \\
}
% ----------------------------------------
{ G,L,RO |- match(e){case Some(x) => e_1; case None => e_2 } : \tau}\\
\inference[GenMatch]
{ G,L,RO |- e : \mathsf{Enum}(\overline{cs}) \\
  G,L \cup \{(\overline{c_i} \cdot \overline{\tau_i})\},RO |- e_i : \tau (C_i, \overline{\tau_i}) \in \overline{cs}\\
  \overline{cs} \setminus \{ C_1, \ldots, C_n \} = \emptyset
}
{ G,L,RO |- match(e){case C_1(\overline{c_1}) => e_1; ... ; case C_n(\overline{c_n}) => e_n } : \tau}
\end{array}
\]
-}
  expressionType e >>= \case {
  -- Base Types PM
   Option pty     -> pmOption pty cs;
   ;
  -- User defined PM only Enums
   DefinedType id -> getEnumTy id >>= pmEnums cs
   }

-- Not assuming anything. Ordering matchs just in case.
-- pmEnums :: [MatchCase SemanticAnns] -> [EnumVariant SemanticAnns] -> m Type
-- pmEnums mc evs = join $ checkSame <$> (zipWithM pmEnumsS sorted_mc sorted_evs)
--   where
--     checkSame :: SemMonad m => [Type] -> m Type
--     checkSame []     = throwError EMCEmpty
--     checkSame (t:ts) = foldM (=?=) t ts
--     sorted_mc :: [MatchCase SemAnn]
--     sorted_mc = sortOn matchIdentifier mc
--     sorted_evs :: [EnumVariant SemAnn]
--     sorted_evs = sortOn variantIdentifier evs
--     pmEnumsS :: SemMonad m => MatchCase SemAnn -> EnumVariant SemAnn -> m Type
--     pmEnumsS mc ev =
--       if matchIdentifier mc == variantIdentifier ev
--       then
--         either throwError
--         (\scope -> addTempVars
--           scope
--           (retblockType (matchBody mc)))
--         (zipSameLength EMCMissingArgs EMCMoreArgs (,) (matchBVars mc) (assocData ev))
--       else throwError (EMCMissingEnum (variantIdentifier ev))

pmOption :: SemMonad m => Type -> [MatchCase SemAnn] -> m Type
pmOption ty [cs1, cs2] =
  if matchIdentifier cs1 == "None" then pmOption' ty cs1 cs2
  else pmOption' ty cs2 cs1
  where
    noneConditions cs = matchIdentifier cs == "None" && Prelude.null(matchBVars cs)
    someConditions cs = matchIdentifier cs == "Some" && length(matchBVars cs) == 1
    -- I am sure this could be improved
    pmOption' :: SemMonad m => Type -> MatchCase SemAnn -> MatchCase SemAnn -> m Type
    pmOption' ty csnone cssome =
     if noneConditions csnone
     then if someConditions cssome
          then do
            tyNone <- retblockType (matchBody csnone)
            tySome <- case matchBVars cssome of
              [v] -> addTempVars [(v,ty)] (retblockType (matchBody cssome))
              _   -> throwError EPMMoreOptionsVariables
            tyNone =?= tySome
          else throwError EPMMissingOption1
     else throwError EPMMissingOption0
pmOption _ []        = throwError EPMMissingOption0
pmOption _ [_]       = throwError EPMMissingOption1
pmOption _ _ = throwError EPMMoreOptions
#+end_src

* Declaration Statement
#+begin_src latex
\[
\inference[varDecDef]
{ x \notin G \cup L \cup RO % No shadow binding
  \mathsf{Default}(\tau) % \tau accepts default value? TODO Q18
}
% ----------------------------------------
{G, L, RO |- \texttt{var} x : \tau  \leadsto G,L \cup \{(x,\tau)\}, RO}
\]

\[
\inference[varDecVal]
{ x \notin G \cup L \cup RO % No shadow binding
  G, L, RO |- e : \tau \\
}
% ----------------------------------------
{ (G, L, RO) \{ \texttt{var} x : \tau = e \}(G,L \cup \{(x,\tau)\}, RO)}
\]
#+end_src
* Assignment Statement
#+begin_src latex
\[
\inference[assign]
{ (x, \tau) \in L \\
  G, L, RO |- e : \tau
}
% ----------------------------------------
{(G, L, RO) \{x = e\} (G,L \cup \{(x,\tau)\}, RO)}
\]
#+end_src

* IfElse Statement
#+begin_src latex
\[
\inference[ifElse]
{  G, L, RO |- e : \mathsf{Bool} \\
  {G, L, RO} \{ b_{tt} \} {G, L, RO} \\
  {G, L, RO} \{ b_{ff} \} {G, L, RO} \\
}
% ----------------------------------------
{(G, L, RO) \{ \texttt{if} (e) \{ b_{tt} \} \texttt{else} \{ b_{ff}\}  \} (G,L,RO)}
\]
#+end_src

* ForLoop Statement
#+begin_src latex
\[
\inference[forLoop]
{ G, L, RO |- e_{l} : \tau  \\
  G, L, RO |- e_{u} : \tau \\
  \mathsf{NumTy}(\tau) \\
  \llbraces e_{l} \rrbraces \leq \llbraces e_{u} \rrbraces \\
  {G, L, RO \cup \{(i, \tau)\}} \{ b_{body} \} {G, L, RO \cup \{(i, \tau)\}}
}
% ----------------------------------------
{(G, L, RO) \{ \texttt{for} i \texttt{in} e_{l} e_{u} { \mathsf{body} } \} (G,L,RO)}
\]
\[
\inference[forLoop]
{ G, L, RO |- e_{l} : \tau  \\
  G, L, RO |- e_{u} : \tau \\
  G, L, RO |- e_{w} : \mathsf{Bool} \\
  \mathsf{NumTy}(\tau) \\
  \llbraces e_{l} \rrbraces \leq \llbraces e_{u} \rrbraces \\
  {G, L, RO \cup \{(i, \tau)\}} \{ b_{body} \} {G, L, RO \cup \{(i, \tau)\}}
}
% ----------------------------------------
{(G, L, RO) \{ \texttt{for} i \texttt{in} e_{l} e_{u} \texttt{while} e_{w} { \mathsf{body} } \} (G,L,RO)}
\]
#+end_src

* Expression Statement
#+begin_src latex
\[
\inference[singleExp]
{ G, L, RO |- e : \tau  \\}
% ----------------------------------------
{(G, L, RO) \{ e \} (G,L,RO)}
\]
#+end_src
