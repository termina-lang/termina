* Termina Language/Transpiler Implementation

* Example

#+begin_src bash
stack run -- --print --output=examples/res.c examples/datadefs.fin
#+end_src

* List of TODOs!
** DONE Create Project
** DONE First AST (Annotated AST)
Termina expressions are a (proper) subset of C, but it has 4 different top level constructs.
- Global variables?
- Rutines
- Functions
- I forgot the last one.
** DONE Simple Parser
** DONE Simple Pretty Printer
** TODO Simple C99 Printer
** DONE Ask Pablo: ClassMethod Ty Nothing?? Translates to void?
** DONE Ask Pablo: Variables types and scope.
Do we allow local shadowing? Local variables can have the same name as global ones shadowing them?

We do not allow shadowing.
** DONE [Q0] Type of constants. Literal numbers?
#+begin_src rust
let i : i32 = (45325245453252454532524545325245 : i32);
#+end_src

#+begin_src c
int i;
i = 45325245u;
#+end_src

#+begin_src haskell
AssignmentStmt (Variable "i")
  (Constant (I 45.245)) [] :: Statement a
#+end_src

Sol: Type annotations over constants
** TODO Constants are in their type? Wait until we have something better to check overflows and stuff?
** DONE Types of operations, multiplication division, it seems they are overloaded.
Overloaded.
** TODO [Q2] Type bitwiseshifts. Type dependent?
Isn't a shift bigger than the size of a variables undefined?
~(>>) : iY -> iX -> iY with {Y >= X}~?

Check Misra C + C std, etc. SAT, abstract interpretation, etc

** DONE [Q1] Type aliases are equivalent?
#+begin_quote
type A int
type B int

var a : A = 1
var b : B = 2

if (a == b)
then print "Capaz que sí"
else print "Capaz que no"
#+end_quote
Name equality.

However, Vectors are structural equivalent, no?

#+begin_src termina
type A Vector i32 5

let a : A = [1,2,3,4,5]
let b : Vector i32 5 = [1,2,3,4,5]

if a == b
then print("Capaz que sí")
else print("Capaz que no")
#+end_src

No, Name Equality, two types with different /names/ are different!

** DONE FunctionExpression shouldn't it be ~FunctionExpression Ident [Expression a]~?

#+begin_src haskell
return $ \case {
                Identifier fs -> FunctionExpression fs arguments);
                _ -> fail;
}
#+end_src

small example

#+begin_src termina
fn f(a : i32){return g(32)}
#+end_src

#+begin_src haskell
strParse "fn f(a : i32){return g((32::i32) + (45::i32));}"
#+end_src
Res
#+begin_src haskell
Right [Function "f" [Parameter {paramIdentifier = "a", paramTypeSpecifier = Int32}] Nothing (BlockRet {blockBody = [], blockRet = (Just (FunctionExpression "g" [BinOp Addition (Constant (I Int32 32)) (Constant (I Int32 45))]),[Position (line 1, column 15)])}) [Position (line 1, column 1)]]
#+end_src

** DONE [Q3] ~FieldValuesAssignmentsExpression fs? : ??~
Added type Type name.
Like in Rust,C, etc
#+begin_src rust
let t : FieldNameTy = FieldNameTy {fn1 : bla, ...}
#+end_src

** IDEA [Q4] Vectors -> Compiling time known length.
Type ~Vector T E~, ~T~ is the type of elements, but what is ~E~? length?

~E~ should be an integer known at compiling time.

The idea of being known at compiler time is implemented using abstract interpretation.
I'll leave it for later, constant folding too.

** DONE [Q5] Patter Matching
*** DONE Compiler types with pattern matching: option.
*** Matching Case semantics.
As it is we have arbitrary expressions.

Classic PM, not almighty racket.

** DONE [Q6] Missing None and Some constructors?
** TODO C compiler flags
** TODO [Q7] String type? there is no string type, check it
** TODO [Q8] Check: x::NumTY, check \(x \in NumTy\)? \(x\) is constant.
** TODO [Q9] What's the type of an empty return? Unit? Unit is not part of our types.
I think we should added or we wont have procedures.
In that case we also should add value ~()~.
** TODO [Q11] Only correct breaks.
Implement stack another check.
** TODO [Q10] Assignment expressions lhs is an expression?

#+begin_src haskell
data Statement a =
  ...
  | AssignmentStmt (Expression a) (Expression a) [ a ]
  ...
#+end_src

I assume this is a mistake, I'll fix it and ask later.
** TODO [Q12] Do we accept procedures?
#+begin_src c
void function_name() { return;}
#+end_src

Reads as
#+begin_src haskell
Function "function_name" [] Nothing ([], Ret ()) [] :: AnnASTElement ()
#+end_src
** TODO [Q13] Why Static, Protected and Const have expressions?
Ask Pablo because I think he wanted to have something more concrete.
Statics should be a memory address? no?
** TODO Constant Environment.
** TODO Implement Error Pretty Printer
